/* tslint:disable */
/* eslint-disable */
/**
 * Malmo API Documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base'
// @ts-ignore
import type { BaseSwaggerResponse } from '../models'
// @ts-ignore
import type { ChatMessageListSuccessResponse } from '../models'
// @ts-ignore
import type { ChatRequest } from '../models'
// @ts-ignore
import type { ChatRoomDeleteSuccessResponse } from '../models'
// @ts-ignore
import type { ChatRoomListSuccessResponse } from '../models'
// @ts-ignore
import type { ChatRoomStateResponse } from '../models'
// @ts-ignore
import type { CompleteChatRoomResponse } from '../models'
// @ts-ignore
import type { DeleteChatRoomRequestDto } from '../models'
// @ts-ignore
import type { GetChatRoomSummaryResponse } from '../models'
// @ts-ignore
import type { Pageable } from '../models'
// @ts-ignore
import type { SendChatSuccessResponse } from '../models'
// @ts-ignore
import type { SwaggerErrorResponse } from '../models'
/**
 * ChatroomApi - axios parameter creator
 * @export
 */
export const ChatroomApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 현재 채팅방을 종료합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 종료
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeChatRoom: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/chatroom/current/complete`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 채팅방을 id 리스트를 통해 다건 동시 삭제합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 삭제
     * @param {DeleteChatRoomRequestDto} deleteChatRoomRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatRooms: async (
      deleteChatRoomRequestDto: DeleteChatRoomRequestDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteChatRoomRequestDto' is not null or undefined
      assertParamExists('deleteChatRooms', 'deleteChatRoomRequestDto', deleteChatRoomRequestDto)
      const localVarPath = `/chatroom`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteChatRoomRequestDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 조건에 부합하는 채팅방 리스트를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 리스트 조회
     * @param {Pageable} pageable
     * @param {string} [keyword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomList: async (
      pageable: Pageable,
      keyword?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getChatRoomList', 'pageable', pageable)
      const localVarPath = `/chatroom`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (pageable !== undefined) {
        for (const [key, value] of Object.entries(pageable)) {
          localVarQueryParameter[key] = value
        }
      }

      if (keyword !== undefined) {
        localVarQueryParameter['keyword'] = keyword
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 채팅방의 메시지를 페이지네이션으로 조회합니다. 현재 채팅방과 달리 시간 오름차순으로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅방의 메시지 리스트 조회
     * @param {Pageable} pageable
     * @param {number} chatRoomId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomMessages: async (
      pageable: Pageable,
      chatRoomId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getChatRoomMessages', 'pageable', pageable)
      // verify required parameter 'chatRoomId' is not null or undefined
      assertParamExists('getChatRoomMessages', 'chatRoomId', chatRoomId)
      const localVarPath = `/chatroom/{chatRoomId}/messages`.replace(
        `{${'chatRoomId'}}`,
        encodeURIComponent(String(chatRoomId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (pageable !== undefined) {
        for (const [key, value] of Object.entries(pageable)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 해당하는 채팅방의 요약를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 요약 조회
     * @param {number} chatRoomId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentChatRoom: async (chatRoomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chatRoomId' is not null or undefined
      assertParamExists('getCurrentChatRoom', 'chatRoomId', chatRoomId)
      const localVarPath = `/chatroom/{chatRoomId}/summary`.replace(
        `{${'chatRoomId'}}`,
        encodeURIComponent(String(chatRoomId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 현재 채팅방의 상태를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 상태 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentChatRoom1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/chatroom/current`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 현재 채팅방의 메시지를 페이지네이션으로 조회합니다. JWT 토큰이 필요합니다.
     * @summary 현재 채팅방 메시지 조회
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentChatRoomMessages: async (
      pageable: Pageable,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getCurrentChatRoomMessages', 'pageable', pageable)
      const localVarPath = `/chatroom/current/messages`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (pageable !== undefined) {
        for (const [key, value] of Object.entries(pageable)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 현재 채팅방의 단계를 업그레이드합니다. 다음 단계의 오프닝 멘트를 SSE로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 단계 변경
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/chatroom/current/upgrade`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 서버로 AI 상담을 위한 사용자의 메시지를 전달합니다. AI 응답은 SSE로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅 메시지 전송
     * @param {ChatRequest} chatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage1: async (chatRequest: ChatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chatRequest' is not null or undefined
      assertParamExists('sendChatMessage1', 'chatRequest', chatRequest)
      const localVarPath = `/chatroom/current/send`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(chatRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ChatroomApi - functional programming interface
 * @export
 */
export const ChatroomApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChatroomApiAxiosParamCreator(configuration)
  return {
    /**
     * 현재 채팅방을 종료합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 종료
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async completeChatRoom(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteChatRoomResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.completeChatRoom(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.completeChatRoom']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 채팅방을 id 리스트를 통해 다건 동시 삭제합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 삭제
     * @param {DeleteChatRoomRequestDto} deleteChatRoomRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChatRooms(
      deleteChatRoomRequestDto: DeleteChatRoomRequestDto,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomDeleteSuccessResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatRooms(deleteChatRoomRequestDto, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.deleteChatRooms']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 조건에 부합하는 채팅방 리스트를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 리스트 조회
     * @param {Pageable} pageable
     * @param {string} [keyword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChatRoomList(
      pageable: Pageable,
      keyword?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomListSuccessResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChatRoomList(pageable, keyword, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.getChatRoomList']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 채팅방의 메시지를 페이지네이션으로 조회합니다. 현재 채팅방과 달리 시간 오름차순으로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅방의 메시지 리스트 조회
     * @param {Pageable} pageable
     * @param {number} chatRoomId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChatRoomMessages(
      pageable: Pageable,
      chatRoomId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatMessageListSuccessResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChatRoomMessages(pageable, chatRoomId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.getChatRoomMessages']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 해당하는 채팅방의 요약를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 요약 조회
     * @param {number} chatRoomId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentChatRoom(
      chatRoomId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatRoomSummaryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentChatRoom(chatRoomId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.getCurrentChatRoom']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 현재 채팅방의 상태를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 상태 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentChatRoom1(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomStateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentChatRoom1(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.getCurrentChatRoom1']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 현재 채팅방의 메시지를 페이지네이션으로 조회합니다. JWT 토큰이 필요합니다.
     * @summary 현재 채팅방 메시지 조회
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentChatRoomMessages(
      pageable: Pageable,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatMessageListSuccessResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentChatRoomMessages(pageable, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.getCurrentChatRoomMessages']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 현재 채팅방의 단계를 업그레이드합니다. 다음 단계의 오프닝 멘트를 SSE로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 단계 변경
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendChatMessage(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseSwaggerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendChatMessage(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.sendChatMessage']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * 서버로 AI 상담을 위한 사용자의 메시지를 전달합니다. AI 응답은 SSE로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅 메시지 전송
     * @param {ChatRequest} chatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendChatMessage1(
      chatRequest: ChatRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendChatSuccessResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendChatMessage1(chatRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ChatroomApi.sendChatMessage1']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ChatroomApi - factory interface
 * @export
 */
export const ChatroomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ChatroomApiFp(configuration)
  return {
    /**
     * 현재 채팅방을 종료합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 종료
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeChatRoom(options?: RawAxiosRequestConfig): AxiosPromise<CompleteChatRoomResponse> {
      return localVarFp.completeChatRoom(options).then((request) => request(axios, basePath))
    },
    /**
     * 채팅방을 id 리스트를 통해 다건 동시 삭제합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 삭제
     * @param {ChatroomApiDeleteChatRoomsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatRooms(
      requestParameters: ChatroomApiDeleteChatRoomsRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ChatRoomDeleteSuccessResponse> {
      return localVarFp
        .deleteChatRooms(requestParameters.deleteChatRoomRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 조건에 부합하는 채팅방 리스트를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 리스트 조회
     * @param {ChatroomApiGetChatRoomListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomList(
      requestParameters: ChatroomApiGetChatRoomListRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ChatRoomListSuccessResponse> {
      return localVarFp
        .getChatRoomList(requestParameters.pageable, requestParameters.keyword, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 채팅방의 메시지를 페이지네이션으로 조회합니다. 현재 채팅방과 달리 시간 오름차순으로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅방의 메시지 리스트 조회
     * @param {ChatroomApiGetChatRoomMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomMessages(
      requestParameters: ChatroomApiGetChatRoomMessagesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ChatMessageListSuccessResponse> {
      return localVarFp
        .getChatRoomMessages(requestParameters.pageable, requestParameters.chatRoomId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 해당하는 채팅방의 요약를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 요약 조회
     * @param {ChatroomApiGetCurrentChatRoomRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentChatRoom(
      requestParameters: ChatroomApiGetCurrentChatRoomRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetChatRoomSummaryResponse> {
      return localVarFp
        .getCurrentChatRoom(requestParameters.chatRoomId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 현재 채팅방의 상태를 조회합니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 상태 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentChatRoom1(options?: RawAxiosRequestConfig): AxiosPromise<ChatRoomStateResponse> {
      return localVarFp.getCurrentChatRoom1(options).then((request) => request(axios, basePath))
    },
    /**
     * 현재 채팅방의 메시지를 페이지네이션으로 조회합니다. JWT 토큰이 필요합니다.
     * @summary 현재 채팅방 메시지 조회
     * @param {ChatroomApiGetCurrentChatRoomMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentChatRoomMessages(
      requestParameters: ChatroomApiGetCurrentChatRoomMessagesRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ChatMessageListSuccessResponse> {
      return localVarFp
        .getCurrentChatRoomMessages(requestParameters.pageable, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 현재 채팅방의 단계를 업그레이드합니다. 다음 단계의 오프닝 멘트를 SSE로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅방 단계 변경
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage(options?: RawAxiosRequestConfig): AxiosPromise<BaseSwaggerResponse> {
      return localVarFp.sendChatMessage(options).then((request) => request(axios, basePath))
    },
    /**
     * 서버로 AI 상담을 위한 사용자의 메시지를 전달합니다. AI 응답은 SSE로 전달됩니다. JWT 토큰이 필요합니다.
     * @summary 채팅 메시지 전송
     * @param {ChatroomApiSendChatMessage1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendChatMessage1(
      requestParameters: ChatroomApiSendChatMessage1Request,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SendChatSuccessResponse> {
      return localVarFp
        .sendChatMessage1(requestParameters.chatRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for deleteChatRooms operation in ChatroomApi.
 * @export
 * @interface ChatroomApiDeleteChatRoomsRequest
 */
export interface ChatroomApiDeleteChatRoomsRequest {
  /**
   *
   * @type {DeleteChatRoomRequestDto}
   * @memberof ChatroomApiDeleteChatRooms
   */
  readonly deleteChatRoomRequestDto: DeleteChatRoomRequestDto
}

/**
 * Request parameters for getChatRoomList operation in ChatroomApi.
 * @export
 * @interface ChatroomApiGetChatRoomListRequest
 */
export interface ChatroomApiGetChatRoomListRequest {
  /**
   *
   * @type {Pageable}
   * @memberof ChatroomApiGetChatRoomList
   */
  readonly pageable: Pageable

  /**
   *
   * @type {string}
   * @memberof ChatroomApiGetChatRoomList
   */
  readonly keyword?: string
}

/**
 * Request parameters for getChatRoomMessages operation in ChatroomApi.
 * @export
 * @interface ChatroomApiGetChatRoomMessagesRequest
 */
export interface ChatroomApiGetChatRoomMessagesRequest {
  /**
   *
   * @type {Pageable}
   * @memberof ChatroomApiGetChatRoomMessages
   */
  readonly pageable: Pageable

  /**
   *
   * @type {number}
   * @memberof ChatroomApiGetChatRoomMessages
   */
  readonly chatRoomId: number
}

/**
 * Request parameters for getCurrentChatRoom operation in ChatroomApi.
 * @export
 * @interface ChatroomApiGetCurrentChatRoomRequest
 */
export interface ChatroomApiGetCurrentChatRoomRequest {
  /**
   *
   * @type {number}
   * @memberof ChatroomApiGetCurrentChatRoom
   */
  readonly chatRoomId: number
}

/**
 * Request parameters for getCurrentChatRoomMessages operation in ChatroomApi.
 * @export
 * @interface ChatroomApiGetCurrentChatRoomMessagesRequest
 */
export interface ChatroomApiGetCurrentChatRoomMessagesRequest {
  /**
   *
   * @type {Pageable}
   * @memberof ChatroomApiGetCurrentChatRoomMessages
   */
  readonly pageable: Pageable
}

/**
 * Request parameters for sendChatMessage1 operation in ChatroomApi.
 * @export
 * @interface ChatroomApiSendChatMessage1Request
 */
export interface ChatroomApiSendChatMessage1Request {
  /**
   *
   * @type {ChatRequest}
   * @memberof ChatroomApiSendChatMessage1
   */
  readonly chatRequest: ChatRequest
}

/**
 * ChatroomApi - object-oriented interface
 * @export
 * @class ChatroomApi
 * @extends {BaseAPI}
 */
export class ChatroomApi extends BaseAPI {
  /**
   * 현재 채팅방을 종료합니다. JWT 토큰이 필요합니다.
   * @summary 채팅방 종료
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public completeChatRoom(options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .completeChatRoom(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 채팅방을 id 리스트를 통해 다건 동시 삭제합니다. JWT 토큰이 필요합니다.
   * @summary 채팅방 삭제
   * @param {ChatroomApiDeleteChatRoomsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public deleteChatRooms(requestParameters: ChatroomApiDeleteChatRoomsRequest, options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .deleteChatRooms(requestParameters.deleteChatRoomRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 조건에 부합하는 채팅방 리스트를 조회합니다. JWT 토큰이 필요합니다.
   * @summary 채팅방 리스트 조회
   * @param {ChatroomApiGetChatRoomListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public getChatRoomList(requestParameters: ChatroomApiGetChatRoomListRequest, options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .getChatRoomList(requestParameters.pageable, requestParameters.keyword, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 채팅방의 메시지를 페이지네이션으로 조회합니다. 현재 채팅방과 달리 시간 오름차순으로 전달됩니다. JWT 토큰이 필요합니다.
   * @summary 채팅방의 메시지 리스트 조회
   * @param {ChatroomApiGetChatRoomMessagesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public getChatRoomMessages(
    requestParameters: ChatroomApiGetChatRoomMessagesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ChatroomApiFp(this.configuration)
      .getChatRoomMessages(requestParameters.pageable, requestParameters.chatRoomId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 해당하는 채팅방의 요약를 조회합니다. JWT 토큰이 필요합니다.
   * @summary 채팅방 요약 조회
   * @param {ChatroomApiGetCurrentChatRoomRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public getCurrentChatRoom(requestParameters: ChatroomApiGetCurrentChatRoomRequest, options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .getCurrentChatRoom(requestParameters.chatRoomId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 현재 채팅방의 상태를 조회합니다. JWT 토큰이 필요합니다.
   * @summary 채팅방 상태 조회
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public getCurrentChatRoom1(options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .getCurrentChatRoom1(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 현재 채팅방의 메시지를 페이지네이션으로 조회합니다. JWT 토큰이 필요합니다.
   * @summary 현재 채팅방 메시지 조회
   * @param {ChatroomApiGetCurrentChatRoomMessagesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public getCurrentChatRoomMessages(
    requestParameters: ChatroomApiGetCurrentChatRoomMessagesRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ChatroomApiFp(this.configuration)
      .getCurrentChatRoomMessages(requestParameters.pageable, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 현재 채팅방의 단계를 업그레이드합니다. 다음 단계의 오프닝 멘트를 SSE로 전달됩니다. JWT 토큰이 필요합니다.
   * @summary 채팅방 단계 변경
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public sendChatMessage(options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .sendChatMessage(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 서버로 AI 상담을 위한 사용자의 메시지를 전달합니다. AI 응답은 SSE로 전달됩니다. JWT 토큰이 필요합니다.
   * @summary 채팅 메시지 전송
   * @param {ChatroomApiSendChatMessage1Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatroomApi
   */
  public sendChatMessage1(requestParameters: ChatroomApiSendChatMessage1Request, options?: RawAxiosRequestConfig) {
    return ChatroomApiFp(this.configuration)
      .sendChatMessage1(requestParameters.chatRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
